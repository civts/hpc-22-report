\section{Problem analysis}
\label{sec:problem_analysis}

% description of the problem
The na\"ive solution to this problem would be to take each point
in the plane and calculate the distance between that point and all
the other points. The time complexity for this solution is $\Theta(N^2)$,
where $N\coloneqq|S|$ is the cardinality of the set $S$.

% Better solutions have been proposed, in particular in 1975
% Rabin proposed a stocastic algorithm with an expected run time
% of $O(N)$.

In 1975, Shamos and Hoey proved that the lower bound for the problem is $\Omega(N * log(N))$\cite[ยง2, theorem 1]{closest_pair_definition}. An algorithm with said complexity appears
the following year from Bentley and Shamos \cite{divide_and_conq_3NlgN}.
% in a book by Preparata and Shamos \cite[ยง5.4]{preparata1993computational}.
A new version of that algortihm was proposed in 2006, reducing the time complexity by a factor of two \cite{ge2006improved}.

For the purposes of this research, we decided to implement the version of Bentley and Shamos, which falls into the best category of complexity whilst still keeping the base algorithm relatively simple, aiding the comprehension of the code.
% For this research, we chose to use a divide and conquer approach
% with $O(N*(logN)^2)$ time complexity. We chose it because
% divide and conquer is highly parallelizable so it will be easier
% to exploit the computational power of the HPC cluster.

\subsection{Algorithm explanation}

In order to solve the closest pair of points problem, we apply the divide et impera approach described in \cite{divide_and_conq_3NlgN}.

Our function accepts as input an array of $N$ points. As a first step, this array is sorted in ascending order according to the X coordinate ($\Theta(N*log(N))$).

If the length of the array is two, then the distance between these two points is the minimum one.

If the length of the array is three, we compute the three distances between the pairs of points and return the minimum one.

If the length is greater than three, we:
\begin{inlinelist}
    \item divide the points by splitting them in two halves of length $\lfloor \frac{N}{2} \rfloor$ and $\lceil \frac{N}{2} \rceil$,
    \item find the closest pair in each half by recursively calling the closest pair of points function on them,
    \item merge the two results to find the closest pair in the starting array. \label{step:merge}
\end{inlinelist}

Let us focus our attention on step \ref{step:merge}: the merge.

In order to combine the two partial results, we first determine which among the the two pairs has the smallest distance, let that be $\delta$.

Next, we condiser a vertical band of points of thickness $2\delta$ centered on the line we used to split the points -i.e., it has an X coordinate equal to the median of the X coordinates of the rightmost point of the left half and the leftmost point of the right half-.

After having sorted the points in that band according to their Y coordinate, we search if they contain a pair closer than $\delta$.

To do so, we compute the distance between each point and the five that come after it (), updating our closest pair if we find a couple of points that is closer than the minimum distance.

\subsubsection{Merge}
The merge operation is a crucial part in the algorithm.
The first thing to do is to take two adjacent subsets and compare the distances
found in each subset and take the pair of points with smaller distance. Then we
need to look at the boundary between the two subsets and check the distances of
the pairs where one point belongs to one subset and one point belongs to the other
subset. To check these points we first select the strip of points with $x$ distance smaller
than the current smaller distance, then we sort the selected points by the $y$ coordinate.
Finally, for each point in the strip we calculate the distance between that point and
the $7$ points around it and we compare this distance with the smaller distance found so far.
It can be proven matematically that 7 is the maximum number of points to check since, if there
would be closer points, a smaller distance would have been found in the previous step.
(Decidere se spiegare meglio e/o aggiungere l'immagine)

\subsection{Implementation}
To implement the serial algorithm we started by implementing the \verb+closest_points_divide+
function that takes an array of points already sorted by the x coordinate and split the array in two
halves and recursively computes the distances of each half using the \verb+closest_points_rec+
function. After the distances computation we use the smallest distances to select the points
near the boundary. Then we use the \verb+band_update_result+ to sort these points by the $y$ coordinate
and check the distance between each point and the next 6 points.

% state of the art
